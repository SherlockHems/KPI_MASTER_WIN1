# -*- coding: utf-8 -*-
"""KPI_MASTER_v1_05.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18D_VWCjiq1fuDh8wlLWJj0OAw0IaLrdf
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import datetime
import csv
import re
import openpyxl
from openpyxl.styles import Font, Alignment, PatternFill
from openpyxl.utils import get_column_letter
from statsmodels.tsa.seasonal import seasonal_decompose
from statsmodels.tsa.statespace.sarimax import SARIMAX
from datetime import timedelta

# Existing functions (load_initial_holdings, load_trades, load_product_info, load_client_sales, etc.) remain the same

# 创建日期列表
def create_date_list(start_date, end_date):
    date_list = []
    current_date = start_date
    while current_date <= end_date:
        date_list.append(current_date)
        current_date += datetime.timedelta(days=1)
    return date_list

# 清理金额字符串
def clean_money_string(money_str):
    # Remove any non-digit characters except for the decimal point and the minus sign
    cleaned = re.sub(r'[^\d.-]', '', money_str)
    return float(cleaned)

# 加载初始持仓
def load_initial_holdings(filename):
    holdings = {}
    with open(filename, 'r', encoding='utf-8') as file:
        csv_reader = csv.DictReader(file)
        for row in csv_reader:
            client_name = row['CLIENT_NAME']
            fund_name = row['FUND_NAME']
            money_value = clean_money_string(row['MONEY_VALUE'])

            if client_name not in holdings:
                holdings[client_name] = {}
            holdings[client_name][fund_name] = money_value

    print(f"Loaded initial holdings for {len(holdings)} clients.")
    return holdings

# 加载交易记录
def load_trades(filename):
    trades = {}
    with open(filename, 'r', encoding='utf-8') as file:
        csv_reader = csv.DictReader(file)
        for row in csv_reader:
            try:
                date = datetime.datetime.strptime(row['CONFIRMED_DATE'], '%Y%m%d').date()
                client_name = row['CLIENT_NAME']
                fund_name = row['FUND_NAME']
                money_changed = clean_money_string(row['MONEY_CHANGED'])

                if client_name not in trades:
                    trades[client_name] = {}
                if fund_name not in trades[client_name]:
                    trades[client_name][fund_name] = {}
                trades[client_name][fund_name][date] = money_changed
            except ValueError as e:
                print(f"Error processing row: {row}")
                print(f"Error message: {str(e)}")
                continue  # Skip this row and continue with the next

    print(f"Loaded trades for {len(trades)} clients.")
    return trades

# 计算每日持仓
def calculate_daily_holdings(initial_holdings, trades, start_date, end_date):
    holdings = {}
    dates = create_date_list(start_date, end_date)

    # Initialize with initial holdings
    for client, funds in initial_holdings.items():
        if client not in holdings:
            holdings[client] = {}
        for fund, amount in funds.items():
            if fund not in holdings[client]:
                holdings[client][fund] = {}
            holdings[client][fund][start_date] = amount

    print("Initialized holdings with initial values.")

    # Calculate daily holdings
    for date in dates[1:]:  # Start from second date
        print(f"\nProcessing date: {date}")

        # Process existing clients and funds
        for client in holdings:
            for fund in holdings[client]:
                prev_date = date - datetime.timedelta(days=1)
                prev_amount = holdings[client][fund][prev_date]

                new_amount = prev_amount
                if client in trades and fund in trades[client] and date in trades[client][fund]:
                    trade_amount = trades[client][fund][date]
                    new_amount = prev_amount + trade_amount
                    print(f"  Updated - {client} - {fund}: {prev_amount:.2f} -> {new_amount:.2f}")

                holdings[client][fund][date] = new_amount

        # Check for new clients or funds in trades
        for client in trades:
            for fund in trades[client]:
                if date in trades[client][fund]:
                    if client not in holdings:
                        holdings[client] = {}
                        print(f"  New client: {client}")
                    if fund not in holdings[client]:
                        holdings[client][fund] = {}
                        print(f"  New fund for {client}: {fund}")

                    if date not in holdings[client][fund]:
                        prev_date = date - datetime.timedelta(days=1)
                        prev_amount = holdings[client][fund].get(prev_date, 0)
                        trade_amount = trades[client][fund][date]
                        new_amount = prev_amount + trade_amount
                        holdings[client][fund][date] = new_amount
                        print(f"  New trade - {client} - {fund}: {prev_amount:.2f} -> {new_amount:.2f}")

        # Print summary for the day
        client_count = len(holdings)
        fund_count = sum(len(funds) for funds in holdings.values())
        print(f"End of day summary - Clients: {client_count}, Funds: {fund_count}")

    return holdings

# 加载产品信息
def load_product_info(filename):
    product_info = {}
    with open(filename, 'r', encoding='utf-8') as file:
        csv_reader = csv.DictReader(file)
        for row in csv_reader:
            fund_name = row['FUND_NAME']
            ma_fees_daily = float(row['MA_FEES_DAILY'])
            product_info[fund_name] = ma_fees_daily

    print(f"Loaded product info for {len(product_info)} funds.")
    return product_info

# 加载客户销售信息
def load_client_sales(filename):
    client_sales = {}
    encodings = ['utf-8', 'iso-8859-1', 'gb18030', 'gb2312', 'gbk']

    for encoding in encodings:
        try:
            with open(filename, 'r', encoding=encoding) as file:
                csv_reader = csv.DictReader(file)
                for row in csv_reader:
                    client_name = row['CLIENT_NAME']
                    sales_person = row['SALES']
                    client_sales[client_name] = sales_person

            print(f"Loaded sales info for {len(client_sales)} clients using {encoding} encoding.")
            return client_sales
        except UnicodeDecodeError:
            continue

    raise ValueError(f"Unable to decode {filename} with any of the attempted encodings.")

# The rest of the code remains the same






def calculate_daily_income(daily_holdings, product_info, client_sales):
    daily_income = {}
    sales_income = {}
    client_income = {}

    all_dates = set()
    for client_funds in daily_holdings.values():
        for fund_holdings in client_funds.values():
            all_dates.update(fund_holdings.keys())
    dates = sorted(list(all_dates))

    for date in dates:
        daily_income[date] = {}
        sales_income[date] = {}
        client_income[date] = {}

        for client, funds in daily_holdings.items():
            client_daily_income = {}
            for fund, holdings in funds.items():
                if date in holdings:
                    if fund in product_info:
                        fund_income = holdings[date] * product_info[fund]
                        client_daily_income[fund] = fund_income
                    else:
                        print(f"Warning: No product info for fund {fund}")
                else:
                    print(f"Warning: No holding data for {client} - {fund} on {date}")

            daily_income[date][client] = client_daily_income
            client_income[date][client] = sum(client_daily_income.values())

            sales_person = client_sales.get(client, "Unknown")
            if sales_person not in sales_income[date]:
                sales_income[date][sales_person] = 0
            sales_income[date][sales_person] += sum(client_daily_income.values())

        print(f"Processed income for date: {date}")

    return daily_income, sales_income, client_income

def calculate_cumulative_income(daily_income):
    cumulative_income = {}
    for date in sorted(daily_income.keys()):
        if not cumulative_income:
            cumulative_income[date] = daily_income[date]
        else:
            prev_date = max(d for d in cumulative_income.keys() if d < date)
            cumulative_income[date] = {
                entity: cumulative_income[prev_date].get(entity, 0) + daily_income[date].get(entity, 0)
                for entity in set(cumulative_income[prev_date]) | set(daily_income[date])
            }
    return cumulative_income

def show_income_statistics(daily_income, sales_income, client_income, daily_holdings, product_info):
    # Client statistics
    client_data = [(date, client, income)
                   for date, clients in client_income.items()
                   for client, income in clients.items()]
    client_df = pd.DataFrame(client_data, columns=['Date', 'Client', 'Income'])
    client_df.set_index(['Date', 'Client'], inplace=True)
    client_stats = client_df.groupby('Client')['Income'].describe()

    # Fund statistics
    fund_data = [(date, client, fund, holdings * product_info.get(fund, 0))
                 for date, clients in daily_holdings.items()
                 for client, funds in clients.items()
                 for fund, holdings in funds.items()]
    fund_df = pd.DataFrame(fund_data, columns=['Date', 'Client', 'Fund', 'Income'])
    fund_df.set_index(['Date', 'Client', 'Fund'], inplace=True)
    fund_stats = fund_df.groupby('Fund')['Income'].describe()

    # Sales person statistics
    sales_data = [(date, sales_person, income)
                  for date, sales_persons in sales_income.items()
                  for sales_person, income in sales_persons.items()]
    sales_df = pd.DataFrame(sales_data, columns=['Date', 'Sales Person', 'Income'])
    sales_df.set_index(['Date', 'Sales Person'], inplace=True)
    sales_stats = sales_df.groupby('Sales Person')['Income'].describe()

    return client_stats, fund_stats, sales_stats

def forecast_income_simple(daily_income, product_info, daily_holdings, start_date, end_date):
    """
    Simple forecasting model assuming no changes in holdings.
    """
    forecast_dates = pd.date_range(start=start_date, end=end_date)
    forecast = {}

    last_known_date = max(daily_income.keys())
    for date in forecast_dates:
        daily_forecast = 0
        for client, funds in daily_holdings.items():
            for fund, holdings in funds.items():
                if last_known_date in holdings:
                    daily_forecast += holdings[last_known_date] * product_info.get(fund, 0)
        forecast[date] = daily_forecast

    return forecast

def forecast_income_complex(daily_income, product_info, daily_holdings, trades, start_date, end_date):
    """
    Complex forecasting model incorporating trading patterns and seasonality.
    """
    # Convert daily_income to a pandas Series
    income_series = pd.Series({k: sum(v.values()) for k, v in daily_income.items()})
    income_series.index = pd.to_datetime(income_series.index)

    # Ensure we have enough data for seasonal decomposition
    if len(income_series) < 14:  # Minimum 2 weeks of data
        return forecast_income_simple(daily_income, product_info, daily_holdings, start_date, end_date)

    # Perform seasonal decomposition
    decomposition = seasonal_decompose(income_series, model='additive', period=7)  # Assuming weekly seasonality

    # Fit SARIMA model
    model = SARIMAX(income_series,
                    order=(1, 1, 1),  # (p,d,q) - Adjust these parameters as needed
                    seasonal_order=(1, 1, 1, 7),  # (P,D,Q,s) - Adjust these parameters as needed
                    enforce_stationarity=False,
                    enforce_invertibility=False)
    results = model.fit()

    # Generate forecast
    forecast_dates = pd.date_range(start=start_date, end=end_date)
    forecast = results.forecast(steps=len(forecast_dates))

    # Adjust forecast based on known future trades
    for date in forecast_dates:
        for client, client_trades in trades.items():
            for fund, fund_trades in client_trades.items():
                if date in fund_trades:
                    trade_amount = fund_trades[date]
                    forecast[date] += trade_amount * product_info.get(fund, 0)

    return forecast.to_dict()

def generate_forecasts(daily_income, product_info, daily_holdings, trades, end_date):
    """
    Generate forecasts using both simple and complex models.
    """
    last_known_date = max(daily_income.keys())
    start_date = last_known_date + timedelta(days=1)

    if start_date > end_date:
        print(f"Warning: The specified end date ({end_date}) is not after the last known date ({last_known_date}). No forecasts will be generated.")
        return None

    simple_forecast = forecast_income_simple(daily_income, product_info, daily_holdings, start_date, end_date)
    complex_forecast = forecast_income_complex(daily_income, product_info, daily_holdings, trades, start_date, end_date)

    # Calculate cumulative forecasts
    simple_cumulative = pd.Series(simple_forecast).cumsum()
    complex_cumulative = pd.Series(complex_forecast).cumsum()

    return {
        'simple': {
            'daily': simple_forecast,
            'cumulative': simple_cumulative.to_dict()
        },
        'complex': {
            'daily': complex_forecast,
            'cumulative': complex_cumulative.to_dict()
        }
    }

def generate_sales_person_breakdowns(daily_income, client_sales):
    sales_person_breakdowns = {}
    for date, clients in daily_income.items():
        sales_person_breakdowns[date] = {}
        for client, funds in clients.items():
            sales_person = client_sales.get(client, "Unknown")
            if sales_person not in sales_person_breakdowns[date]:
                sales_person_breakdowns[date][sales_person] = {"clients": {}, "funds": {}}

            sales_person_breakdowns[date][sales_person]["clients"][client] = sum(funds.values())

            for fund, income in funds.items():
                if fund not in sales_person_breakdowns[date][sales_person]["funds"]:
                    sales_person_breakdowns[date][sales_person]["funds"][fund] = 0
                sales_person_breakdowns[date][sales_person]["funds"][fund] += income

    return sales_person_breakdowns

def generate_client_breakdowns(daily_income):
    client_breakdowns = {}
    for date, clients in daily_income.items():
        client_breakdowns[date] = {}
        for client, funds in clients.items():
            client_breakdowns[date][client] = funds

    return client_breakdowns

def generate_excel_report(daily_income, sales_income, client_income, cumulative_sales_income, cumulative_client_income, client_stats, fund_stats, sales_stats, forecasts, daily_holdings, sales_person_breakdowns, client_breakdowns, workbook):
    # Summary sheet
    summary_sheet = workbook.active
    summary_sheet.title = "Summary"
    summary_sheet['A1'] = "Income Analysis Summary"
    summary_sheet['A1'].font = Font(bold=True, size=14)
    summary_sheet.merge_cells('A1:E1')

    # Daily income summary
    row = 3
    summary_sheet.cell(row=row, column=1, value="Daily Income Summary").font = Font(bold=True)
    row += 1
    headers = ["Date", "Total Income", "Number of Salespeople", "Number of Clients", "Number of Funds"]
    for col, header in enumerate(headers, start=1):
        summary_sheet.cell(row=row, column=col, value=header).font = Font(bold=True)
    row += 1
    for date, incomes in daily_income.items():
        total_income = sum(sum(client_funds.values()) for client_funds in incomes.values())
        num_salespeople = len(sales_income[date])
        num_clients = len(incomes)

        # Count the number of unique funds across all clients for this date
        all_funds = set()
        for client_funds in incomes.values():
            all_funds.update(client_funds.keys())
        num_funds = len(all_funds)

        summary_sheet.cell(row=row, column=1, value=date)
        summary_sheet.cell(row=row, column=2, value=total_income)
        summary_sheet.cell(row=row, column=3, value=num_salespeople)
        summary_sheet.cell(row=row, column=4, value=num_clients)
        summary_sheet.cell(row=row, column=5, value=num_funds)
        row += 1

    # Statistics summary
    row += 2
    summary_sheet.cell(row=row, column=1, value="Statistics Summary").font = Font(bold=True)
    row += 1
    summary_sheet.cell(row=row, column=1, value="Client Statistics")
    summary_sheet.cell(row=row, column=2, value=client_stats.to_string())
    row += len(client_stats) + 2
    summary_sheet.cell(row=row, column=1, value="Fund Statistics")
    summary_sheet.cell(row=row, column=2, value=fund_stats.to_string())
    row += len(fund_stats) + 2
    summary_sheet.cell(row=row, column=1, value="Sales Person Statistics")
    summary_sheet.cell(row=row, column=2, value=sales_stats.to_string())

    # Sales person sheets
    for salesperson in sales_income[list(sales_income.keys())[0]].keys():
        sheet = workbook.create_sheet(title=f"{salesperson} Income")
        sheet['A1'] = f"Daily and Cumulative Income for {salesperson}"
        sheet['A1'].font = Font(bold=True, size=14)
        sheet.merge_cells('A1:C1')

        headers = ["Date", "Daily Income", "Cumulative Income"]
        for col, header in enumerate(headers, start=1):
            sheet.cell(row=3, column=col, value=header).font = Font(bold=True)

        row = 4
        for date in sales_income.keys():
            sheet.cell(row=row, column=1, value=date)
            sheet.cell(row=row, column=2, value=sales_income[date].get(salesperson, 0))
            sheet.cell(row=row, column=3, value=cumulative_sales_income[date].get(salesperson, 0))
            row += 1

        # Add breakdown information
        sheet['E1'] = "Daily Breakdown"
        sheet['E1'].font = Font(bold=True, size=12)
        sheet['E2'] = "Date"
        sheet['F2'] = "Client Breakdown"
        sheet['G2'] = "Fund Breakdown"
        breakdown_row = 3
        for date in sales_income.keys():
            if date in sales_person_breakdowns and salesperson in sales_person_breakdowns[date]:
                sheet.cell(row=breakdown_row, column=5, value=date)
                client_breakdown = ", ".join([f"{client}: {income:.2f}" for client, income in sales_person_breakdowns[date][salesperson]["clients"].items()])
                fund_breakdown = ", ".join([f"{fund}: {income:.2f}" for fund, income in sales_person_breakdowns[date][salesperson]["funds"].items()])
                sheet.cell(row=breakdown_row, column=6, value=client_breakdown)
                sheet.cell(row=breakdown_row, column=7, value=fund_breakdown)
                breakdown_row += 1

    # Client sheets
    for client in client_income[list(client_income.keys())[0]].keys():
        sheet = workbook.create_sheet(title=f"{client} Income")
        sheet['A1'] = f"Daily and Cumulative Income for {client}"
        sheet['A1'].font = Font(bold=True, size=14)
        sheet.merge_cells('A1:C1')

        headers = ["Date", "Daily Income", "Cumulative Income"]
        for col, header in enumerate(headers, start=1):
            sheet.cell(row=3, column=col, value=header).font = Font(bold=True)

        row = 4
        for date in client_income.keys():
            sheet.cell(row=row, column=1, value=date)
            sheet.cell(row=row, column=2, value=client_income[date].get(client, 0))
            sheet.cell(row=row, column=3, value=cumulative_client_income[date].get(client, 0))
            row += 1

        # Add fund breakdown information
        sheet['E1'] = "Daily Fund Breakdown"
        sheet['E1'].font = Font(bold=True, size=12)
        sheet['E2'] = "Date"
        sheet['F2'] = "Fund Breakdown"
        breakdown_row = 3
        for date in client_income.keys():
            if date in client_breakdowns and client in client_breakdowns[date]:
                sheet.cell(row=breakdown_row, column=5, value=date)
                breakdown_value = client_breakdowns[date][client]
                if isinstance(breakdown_value, dict):
                    fund_breakdown = ", ".join([f"{fund}: {income:.2f}" for fund, income in breakdown_value.items()])
                else:
                    fund_breakdown = f"Total: {breakdown_value:.2f}"
                sheet.cell(row=breakdown_row, column=6, value=fund_breakdown)
                breakdown_row += 1

  # Forecast sheet
    forecast_sheet = workbook.create_sheet(title="Forecasts")
    forecast_sheet['A1'] = "Income Forecasts"
    forecast_sheet['A1'].font = Font(bold=True, size=14)
    forecast_sheet.merge_cells('A1:E1')

    if forecasts is not None and 'simple' in forecasts and 'complex' in forecasts:
        headers = ["Date", "Simple Daily", "Simple Cumulative", "Complex Daily", "Complex Cumulative"]
        for col, header in enumerate(headers, start=1):
            forecast_sheet.cell(row=3, column=col, value=header).font = Font(bold=True)

        row = 4
        for date in forecasts['simple']['daily'].keys():
            forecast_sheet.cell(row=row, column=1, value=date)
            forecast_sheet.cell(row=row, column=2, value=forecasts['simple']['daily'][date])
            forecast_sheet.cell(row=row, column=3, value=forecasts['simple']['cumulative'][date])
            forecast_sheet.cell(row=row, column=4, value=forecasts['complex']['daily'][date])
            forecast_sheet.cell(row=row, column=5, value=forecasts['complex']['cumulative'][date])
            row += 1
    else:
        forecast_sheet['A3'] = "No forecast data available"


    for salesperson in sales_income[list(sales_income.keys())[0]].keys():
        sheet = workbook.create_sheet(title=f"{salesperson} Breakdown")
        sheet['A1'] = f"Daily Breakdown for {salesperson}"
        sheet['A1'].font = Font(bold=True, size=14)
        sheet.merge_cells('A1:D1')

        headers = ["Date", "Total Income", "Client Breakdown", "Fund Breakdown"]
        for col, header in enumerate(headers, start=1):
            sheet.cell(row=3, column=col, value=header).font = Font(bold=True)

        row = 4
        for date in sales_income.keys():
            sheet.cell(row=row, column=1, value=date)
            sheet.cell(row=row, column=2, value=sales_income[date].get(salesperson, 0))

            if date in sales_person_breakdowns and salesperson in sales_person_breakdowns[date]:
                client_breakdown = ", ".join([f"{client}: {income}" for client, income in sales_person_breakdowns[date][salesperson]["clients"].items()])
                fund_breakdown = ", ".join([f"{fund}: {income}" for fund, income in sales_person_breakdowns[date][salesperson]["funds"].items()])

                sheet.cell(row=row, column=3, value=client_breakdown)
                sheet.cell(row=row, column=4, value=fund_breakdown)

            row += 1

    for client in client_income[list(client_income.keys())[0]].keys():
        sheet = workbook.create_sheet(title=f"{client} Breakdown")
        sheet['A1'] = f"Daily Fund Breakdown for {client}"
        sheet['A1'].font = Font(bold=True, size=14)
        sheet.merge_cells('A1:C1')

        headers = ["Date", "Total Income", "Fund Breakdown"]
        for col, header in enumerate(headers, start=1):
            sheet.cell(row=3, column=col, value=header).font = Font(bold=True)

        row = 4
        for date in client_income.keys():
            sheet.cell(row=row, column=1, value=date)
            sheet.cell(row=row, column=2, value=client_income[date].get(client, 0))

            if date in client_breakdowns and client in client_breakdowns[date]:
                breakdown_value = client_breakdowns[date][client]
                if isinstance(breakdown_value, dict):
                    fund_breakdown = ", ".join([f"{fund}: {income:.2f}" for fund, income in breakdown_value.items()])
                else:
                    fund_breakdown = f"Total: {breakdown_value:.2f}"
                sheet.cell(row=row, column=3, value=fund_breakdown)

            row += 1

    # Adjust column widths
    for sheet in workbook.worksheets:
        for column in sheet.columns:
            max_length = 0
            column_letter = get_column_letter(column[0].column)
            for cell in column:
                try:
                    if len(str(cell.value)) > max_length:
                        max_length = len(str(cell.value))
                except:
                    pass
            adjusted_width = (max_length + 2)
            sheet.column_dimensions[column_letter].width = adjusted_width

def search_by_client(client_name, data, start_date=None, end_date=None):
    result = {}
    for date, clients in data.items():
        if (start_date is None or date >= start_date) and (end_date is None or date <= end_date):
            if client_name in clients:
                result[date] = clients[client_name]
    return result

def search_by_fund(fund_name, data, start_date=None, end_date=None):
    result = {}
    for date, clients in data.items():
        if (start_date is None or date >= start_date) and (end_date is None or date <= end_date):
            for client, funds in clients.items():
                if fund_name in funds:
                    if date not in result:
                        result[date] = {}
                    result[date][client] = funds[fund_name]
    return result

def search_by_sales_person(sales_person, data, client_sales, start_date=None, end_date=None):
    result = {}
    for date, clients in data.items():
        if (start_date is None or date >= start_date) and (end_date is None or date <= end_date):
            result[date] = {}
            for client, income in clients.items():
                if client_sales.get(client) == sales_person:
                    result[date][client] = income
    return result

def plot_cumulative_income(data, title, filename):
    df = pd.DataFrame(data).T
    df = df.cumsum()

    plt.figure(figsize=(12, 6))
    for column in df.columns:
        plt.plot(df.index, df[column], label=column)

    plt.title(title)
    plt.xlabel('Date')
    plt.ylabel('Cumulative Income')
    plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
    plt.tight_layout()
    plt.savefig(filename)
    plt.close()

def plot_income_composition(data, title, filename):
    df = pd.DataFrame(data)
    df_percentage = df.div(df.sum(axis=1), axis=0) * 100

    plt.figure(figsize=(12, 6))
    df_percentage.plot(kind='area', stacked=True)

    plt.title(title)
    plt.xlabel('Date')
    plt.ylabel('Percentage of Total Income')
    plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
    plt.tight_layout()
    plt.savefig(filename)
    plt.close()

def plot_forecasts(actual_data, forecasts, title, filename):
    actual_df = pd.Series(actual_data).cumsum()
    simple_forecast = pd.Series(forecasts['simple']['cumulative'])
    complex_forecast = pd.Series(forecasts['complex']['cumulative'])

    plt.figure(figsize=(12, 6))
    plt.plot(actual_df.index, actual_df, label='Actual')
    plt.plot(simple_forecast.index, simple_forecast, label='Simple Forecast')
    plt.plot(complex_forecast.index, complex_forecast, label='Complex Forecast')

    plt.title(title)
    plt.xlabel('Date')
    plt.ylabel('Cumulative Income')
    plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
    plt.tight_layout()
    plt.savefig(filename)
    plt.close()

def main():
    start_date = datetime.date(2023, 12, 31)
    end_date = datetime.date(2024, 6, 30)

    print("Loading initial holdings...")
    initial_holdings = load_initial_holdings('api/data/2023DEC.csv')

    print("\nLoading trades...")
    trades = load_trades('api/data/TRADES_LOG.csv')

    print("\nLoading product info...")
    product_info = load_product_info('api/data/PRODUCT_INFO.csv')

    print("\nLoading client sales info...")
    client_sales = load_client_sales('api/data/CLIENT_LIST.csv')

    print("\nCalculating daily holdings...")
    daily_holdings = calculate_daily_holdings(initial_holdings, trades, start_date, end_date)

    print("\nCalculating daily income...")
    daily_income, sales_income, client_income = calculate_daily_income(daily_holdings, product_info, client_sales)

    print("\nCalculating cumulative income...")
    cumulative_sales_income = calculate_cumulative_income(sales_income)
    cumulative_client_income = calculate_cumulative_income(client_income)

    print("\nGenerating income statistics...")
    client_stats, fund_stats, sales_stats = show_income_statistics(daily_income, sales_income, client_income, daily_holdings, product_info)

    print("\nGenerating forecasts...")
    forecasts = generate_forecasts(daily_income, product_info, daily_holdings, trades, end_date)

    print("\nGenerating sales person breakdowns...")
    sales_person_breakdowns = generate_sales_person_breakdowns(daily_income, client_sales)

    print("\nGenerating client breakdowns...")
    client_breakdowns = generate_client_breakdowns(daily_income)

    print("\nGenerating Excel report...")
    wb = openpyxl.Workbook()
    generate_excel_report(daily_income, sales_income, client_income, cumulative_sales_income, cumulative_client_income, client_stats, fund_stats, sales_stats, forecasts, daily_holdings, sales_person_breakdowns, client_breakdowns, wb)
    wb.save('income_analysis_report.xlsx')

    print("\nCalculation complete. Report saved as 'income_analysis_report.xlsx'")


# Add these new functions at the end of your kpi_master_v1_07.py file

def get_sales_person_income(daily_income, client_sales):
    sales_person_income = {}
    for date, clients in daily_income.items():
        for client, funds in clients.items():
            sales_person = client_sales.get(client, "Unknown")
            if sales_person not in sales_person_income:
                sales_person_income[sales_person] = {}
            if date not in sales_person_income[sales_person]:
                sales_person_income[sales_person][date] = 0
            sales_person_income[sales_person][date] += sum(funds.values())
    return sales_person_income


def get_top_clients_and_funds(daily_income, client_sales):
    sales_person_clients = {}
    sales_person_funds = {}
    for date, clients in daily_income.items():
        for client, funds in clients.items():
            sales_person = client_sales.get(client, "Unknown")
            if sales_person not in sales_person_clients:
                sales_person_clients[sales_person] = {}
            if sales_person not in sales_person_funds:
                sales_person_funds[sales_person] = {}

            client_income = sum(funds.values())
            sales_person_clients[sales_person][client] = sales_person_clients[sales_person].get(client,
                                                                                                0) + client_income

            for fund, income in funds.items():
                sales_person_funds[sales_person][fund] = sales_person_funds[sales_person].get(fund, 0) + income

    top_clients = {sp: sorted(clients.items(), key=lambda x: x[1], reverse=True)[:5] for sp, clients in
                   sales_person_clients.items()}
    top_funds = {sp: sorted(funds.items(), key=lambda x: x[1], reverse=True)[:5] for sp, funds in
                 sales_person_funds.items()}

    return top_clients, top_funds


def prepare_sales_data(daily_income, client_sales):
    sales_person_income = get_sales_person_income(daily_income, client_sales)
    top_clients, top_funds = get_top_clients_and_funds(daily_income, client_sales)

    sales_data = {
        'salesPersons': [],
        'dailyContribution': [],
        'individualPerformance': {}
    }

    all_dates = sorted(set(date for sp_data in sales_person_income.values() for date in sp_data.keys()))

    for date in all_dates:
        daily_data = {'date': date.isoformat()}
        for sales_person, income_data in sales_person_income.items():
            daily_data[sales_person] = income_data.get(date, 0)
        sales_data['dailyContribution'].append(daily_data)

    for sales_person, income_data in sales_person_income.items():
        cumulative_income = sum(income_data.values())
        sales_data['individualPerformance'][sales_person] = [
            {'date': date.isoformat(), 'income': income}
            for date, income in sorted(income_data.items())
        ]

        sales_data['salesPersons'].append({
            'name': sales_person,
            'cumulativeIncome': cumulative_income,
            'topClients': [{'name': name, 'income': income} for name, income in top_clients.get(sales_person, [])],
            'topFunds': [{'name': name, 'income': income} for name, income in top_funds.get(sales_person, [])]
        })

    return sales_data

if __name__ == "__main__":
    main()